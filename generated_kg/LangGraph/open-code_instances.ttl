# Execution time: 108.40 seconds
# Model used: gpt-5-mini

# Issues / Assumptions:
# - The ontology does not have a first-class construct for "tool call" (id, args, status). I represent tool call arguments and their structured arrays as Prompt.promptInputData or as dc:description literals (JSON) attached to Prompt/Resource individuals.
# - The ontology does not include a property to represent UI components, UI pushes, or message-level metadata. I capture UI interactions as Tasks/Prompts and describe UI payloads in literal properties. UI component details (component names, props) are stored as string literals.
# - The ontology does not provide a direct way to represent conditional/looping edges in workflows or runtime control-flow logic. I use :nextStep to show the nominal sequence and document the conditional loop in literals on the WorkflowStep and Config individuals.
# - The ontology does not have a property to model "tool call outcome" (accepted/rejected) or per-iteration state. I store the semantics (executedPlans, rejectedPlans, remainingPlans) as literal JSON in Prompt.promptInputData so an LLM can reconstruct the iteration semantics.
# - The ontology has limited support for representing code files as resources. I model files as beam:Instance resources with dc:title for path and dc:description for exact file content (preserving delimiters and code fences).
# - No new classes or properties were added. Where framework-specific concepts exist (typed UI, component maps, SDK types), they are captured as descriptive literals and not modeled as new ontology classes.

@prefix : <http://www.w3id.org/agentic-ai/onto#> .
@prefix pp: <http://purl.org/net/p-plan#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix beam: <http://w3id.org/beam/core#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@base <http://www.w3id.org/agentic-ai/onto#> .

#################################################################
# Individuals for the "Open Code" agent solution
#################################################################

### Agent (LLM)
:OpenCodeAgent rdf:type :LLMAgent ;
  :agentID "open-code-agent-001" ;
  :agentRole "planner-executor LLM agent (coordinates planning and performs file updates via tools and UI prompts)" ;
  rdfs:label "Open Code LLM Agent" ;
  :useLanguageModel :OpenCodeLanguageModel ;
  :hasAgentConfig :OpenCodeAgentConfig ;
  :hasAgentCapability :Capability_Planning , :Capability_UpdateFile , :Capability_UIInteraction ;
  :hasKnowledge :OpenCodeMemory ;
  :hasAgentGoal :Goal_BuildTodoApp ;
  :operatesIn :DevEnvironment ;
  :interactsWith :Human_User .

### Human user who approves/rejects proposals
:Human_User rdf:type :HumanAgent ;
  rdfs:label "End user / approver" ;
  rdfs:comment "Represents the human who reviews proposed file changes and approves or rejects them through the UI." .

### Language model used by the agent (abstract)
:OpenCodeLanguageModel rdf:type :LanguageModel ;
  rdfs:label "OpenCodeLanguageModel" ;
  rdfs:comment "Abstract representation of the language model used by the agent. The code uses an LLM via SDK; model configuration (model name, temperature) is runtime-specific and not modeled here." .

### Environment
:DevEnvironment rdf:type :Environment ;
  :envType "development (file system, browser localStorage, UI)" ;
  rdfs:label "Development environment" ;
  rdfs:comment "Represents the operational context: a code workspace where files are read and updated, and a UI surface that presents proposed changes to a human for approval." ;
  :containsResource :Resource_Step1_File , :Resource_Step2_File , :Resource_Step3_File , :Resource_Step4_File , :Resource_Step5_File , :Resource_Step6_File .

### Goal
:Goal_BuildTodoApp rdf:type :Goal ;
  rdfs:label "Build a Todo App" ;
  rdfs:comment "Top-level goal of the workflow: construct a basic todo application (React + TypeScript) with components, state management, forms, filtering, and persistence." .

### Agent memory / knowledge
:OpenCodeMemory rdf:type :Memory ;
  rdfs:label "Open Code Memory" ;
  <http://purl.org/dc/terms/description> """
Holds the planning state used by the planner/executor loop. Key structured items used at runtime:
- PLAN (ordered array of plan steps for building the todo app).
- last plan tool call args (executedPlans, rejectedPlans, remainingPlans).
This individual stores the canonical PLAN and describes how executed/rejected/remaining lists evolve.
""" .

#################################################################
# Workflow pattern and steps (StateGraph)
#################################################################

:OpenCodeGraphPattern rdf:type :WorkflowPattern ;
  rdfs:label "Open Code Graph" ;
  rdfs:comment "Workflow pattern derived from the StateGraph in index.ts. Contains two main steps: planner and executor." ;
  :hasWorkflowStep :WorkflowStep_Planner , :WorkflowStep_Executor .

### Planner WorkflowStep
:WorkflowStep_Planner rdf:type :WorkflowStep ;
  rdfs:label "planner" ;
  :stepOrder 1 ;
  :hasAssociatedTask :Task_Planner ;
  :nextStep :WorkflowStep_Executor ;
  rdfs:comment "Planner node generates or updates a plan and issues a 'plan' tool_call containing executedPlans, rejectedPlans, remainingPlans. If a proposed change was processed it updates executed/rejected lists." .

### Executor WorkflowStep
:WorkflowStep_Executor rdf:type :WorkflowStep ;
  rdfs:label "executor" ;
  :stepOrder 2 ;
  :hasAssociatedTask :Task_Executor ;
  :nextStep :WorkflowStep_Planner ;
  rdfs:comment "Executor node reads the current plan tool_call. If a remaining plan item exists, it prepares a file update (reads a corresponding file snippet resource) and issues an 'update_file' tool_call plus pushes a UI item 'proposed-change'. If no remaining items, it emits a success AI message and the workflow ends (subject to permissions config)." .

#################################################################
# Tasks and tools
#################################################################

### Planner Task
:Task_Planner rdf:type :Task ;
  rdfs:label "Planner Task (produce plan tool call)" ;
  <http://purl.org/dc/terms/description> """
Generates a plan tool_call with args:
- executedPlans: array of strings (items already executed)
- rejectedPlans: array of strings (items rejected by user)
- remainingPlans: array of strings (items still to execute)
Default PLAN (remainingPlans initial value) is the 6-step plan to build the todo app (see PlanPrompt.promptInputData).
Emits:
- an AI message containing a short summary in content (either initial plan text or 'I've updated the plan list based on the last proposed change.')
- a tool call named 'plan' with the args above
Also produces a ToolMessage representing a simulated user approval ("User has approved the plan.") that the StateGraph uses to progress.
""" ;
  :performedByAgent :OpenCodeAgent ;
  :performedBy :Tool_Plan ;
  :producedResource :PlanArtifact ;
  :requiresCapability :Capability_Planning ;
  :requiresResource :Resource_PlanInput .

### Executor Task
:Task_Executor rdf:type :Task ;
  rdfs:label "Executor Task (apply next plan item via update_file tool call and UI push)" ;
  <http://purl.org/dc/terms/description> """
Reads the last 'plan' tool_call to compute:
- nextPlanItem: the first element of remainingPlans (if any)
- numSeenPlans = executedPlans.length + rejectedPlans.length
If no nextPlanItem: returns an AI message with content:
"Successfully completed all the steps in the plan. Please let me know if you need anything else!"
Otherwise:
- Selects file update content based on numSeenPlans (maps 0..5 to step-1..step-6 file resources).
- Builds a tool_call named 'update_file' with args:
  - new_file_content (string): the file content to write
  - executed_plan_item (string): the plan item description being executed
- Generates an AI message containing the tool_call and pushes a UI item named 'proposed-change' with props { toolCallId, change, planItem, fullWriteAccess }.
The UI push is intended to present the proposed change to the human for approval or rejection.
""" ;
  :performedByAgent :OpenCodeAgent ;
  :performedBy :Tool_UpdateFile ;
  :producedResource :Resource_Step1_File , :Resource_Step2_File , :Resource_Step3_File , :Resource_Step4_File , :Resource_Step5_File , :Resource_Step6_File ;
  :requiresCapability :Capability_UpdateFile , :Capability_UIInteraction .

### Tools
:Tool_Plan rdf:type :Tool ;
  rdfs:label "plan tool" ;
  :hasCapability :Capability_Planning ;
  :hasToolConfig :Config_PlanToolConfig ;
  <http://purl.org/dc/terms/description> "Represents the logical tool 'plan' that is invoked by the planner node to expose executed/rejected/remaining plan lists as tool_call args." .

:Tool_UpdateFile rdf:type :Tool ;
  rdfs:label "update_file tool" ;
  :hasCapability :Capability_UpdateFile ;
  :hasToolConfig :Config_UpdateFileToolConfig ;
  <http://purl.org/dc/terms/description"> "Tool invoked by executor to apply a code/file update. It accepts args { new_file_content, executed_plan_item } and returns a tool message used to indicate acceptance or rejection." .

#################################################################
# Capabilities
#################################################################
:Capability_Planning rdf:type :Capability ;
  rdfs:label "planning" ;
  rdfs:comment "Generate and maintain plan lists (executed, rejected, remaining) and choose next plan item." .

:Capability_UpdateFile rdf:type :Capability ;
  rdfs:label "file update" ;
  rdfs:comment "Prepare file content updates based on plan items and perform write actions (via a tool)." .

:Capability_UIInteraction rdf:type :Capability ;
  rdfs:label "UI interaction / propose changes" ;
  rdfs:comment "Push UI items to present proposed changes to a human and capture approvals or rejections." .

#################################################################
# Configurations
#################################################################
:OpenCodeAgentConfig rdf:type :Config ;
  rdfs:label "Open Code Agent Config" ;
  :configKey "permissions.full_write_access" ;
  :configValue "runtime boolean; when true the executor will loop back to the planner after proposing a change (allowing continued automated edits). When false, the workflow ends after the first success or when the success message is generated." ;
  <http://purl.org/dc/terms/description> "Agent-specific configuration; code checks configurable?.permissions?.full_write_access to decide whether to loop back to planner (full automation) or end after success." .

:Config_UpdateFileToolConfig rdf:type :Config ;
  rdfs:label "Update File Tool Config" ;
  :configKey "update_file.behaviour" ;
  :configValue "Takes args { new_file_content, executed_plan_item }; returns a tool message whose content includes 'rejected' if the proposed change was rejected by the user. The planner inspects tool responses for 'rejected' to move items into rejectedPlans." .

:Config_PlanToolConfig rdf:type :Config ;
  rdfs:label "Plan Tool Config" ;
  :configKey "plan.args.format" ;
  :configValue "JSON object with executedPlans[], rejectedPlans[], remainingPlans[]; initial remainingPlans uses PLAN canonical array stored in PlanPrompt.promptInputData" .

#################################################################
# Prompts and tool-call argument representations
#################################################################

# The canonical plan (six items) used as the initial remainingPlans
:PlanPrompt rdf:type :Prompt ;
  rdfs:label "Plan Prompt / Plan tool_call args" ;
  :promptInstruction "Planner composes or updates the plan and returns a 'plan' tool_call containing executedPlans, rejectedPlans, remainingPlans." ;
  :promptInputData """
[
  "Set up project scaffolding using Create React App and implement basic folder structure for components, styles, and utilities.",
  "Create reusable UI components for TodoItem, including styling with CSS modules.",
  "Implement state management using React Context to handle todo items, including actions for adding, updating, and deleting todos.",
  "Add form functionality for creating new todos with input validation and error handling.",
  "Create filtering and sorting capabilities to allow users to view completed, active, or all todos.",
  "Implement local storage integration to persist todo items between page refreshes."
]
""" ;
  :promptOutputIndicator "A tool_call named 'plan' with args { executedPlans: string[], rejectedPlans: string[], remainingPlans: string[] } and an accompanying AI message summary string." .

# Representation of the update_file tool call and UI push payload
:UpdateFilePrompt rdf:type :Prompt ;
  rdfs:label "Update File Prompt / update_file tool_call args" ;
  :promptInstruction "Executor builds an 'update_file' tool_call with args { new_file_content: string, executed_plan_item: string } and pushes a UI item 'proposed-change' carrying the same information plus fullWriteAccess flag and toolCallId." ;
  :promptInputData """
{
  "args_format": {
    "new_file_content": "string (the source text to write to file)",
    "executed_plan_item": "string (the plan item this change implements)"
  },
  "ui_push": {
    "component": "proposed-change",
    "props": ["toolCallId", "change (new_file_content)", "planItem (executed_plan_item)", "fullWriteAccess (boolean)"]
  }
}
""" ;
  :promptOutputIndicator "An AI message containing the 'update_file' tool_call and a UI push entry; later a tool response from the 'update_file' execution will indicate acceptance or rejection to the planner." .

#################################################################
# Resources produced by executor (file contents are preserved exactly)
#################################################################

# Step 1 resource
:Resource_Step1_File rdf:type beam:Instance ;
  rdfs:label "step-1: scaffold commands" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-1.txt" ;
  <http://purl.org/dc/terms/description> """
```bash
npx create-react-app todo-app --template typescript
cd todo-app
mkdir -p src/{components,styles,utils}
```
""" ;
  rdfs:comment "File content used by executor for plan item 1 (project scaffolding)." .

# Step 2 resource
:Resource_Step2_File rdf:type beam:Instance ;
  rdfs:label "step-2: TodoItem component" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-2.txt" ;
  <http://purl.org/dc/terms/description> """
```tsx
// src/components/TodoItem.tsx
import React from 'react';
import styles from '../styles/TodoItem.module.css';

interface TodoItemProps {
  id: string;
  text: string;
  completed: boolean;
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}

export const TodoItem: React.FC<TodoItemProps> = ({ id, text, completed, onToggle, onDelete }) => (
  <div className={styles.todoItem}>
    <input type='checkbox' checked={completed} onChange={() => onToggle(id)} />
    <span className={completed ? styles.completed : ''}>{text}</span>
    <button onClick={() => onDelete(id)}>Delete</button>
  </div>
);
```
""" ;
  rdfs:comment "File content used by executor for plan item 2 (TodoItem component)." .

# Step 3 resource
:Resource_Step3_File rdf:type beam:Instance ;
  rdfs:label "step-3: TodoContext (state management)" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-3.txt" ;
  <http://purl.org/dc/terms/description> """
```tsx
// src/context/TodoContext.tsx
import React, { createContext, useContext, useReducer } from 'react';

type Todo = { id: string; text: string; completed: boolean; };

type TodoState = { todos: Todo[]; };
type TodoAction = 
  | { type: 'ADD_TODO'; payload: string }
  | { type: 'TOGGLE_TODO'; payload: string }
  | { type: 'DELETE_TODO'; payload: string };

const TodoContext = createContext<{
  state: TodoState;
  dispatch: React.Dispatch<TodoAction>;
} | undefined>(undefined);

export const TodoProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(todoReducer, { todos: [] });
  return <TodoContext.Provider value={{ state, dispatch }}>{children}</TodoContext.Provider>;
};
```
""" ;
  rdfs:comment "File content used by executor for plan item 3 (state management context)." .

# Step 4 resource
:Resource_Step4_File rdf:type beam:Instance ;
  rdfs:label "step-4: AddTodo component (form and validation)" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-4.txt" ;
  <http://purl.org/dc/terms/description> """
```tsx
// src/components/AddTodo.tsx
import React, { useState } from 'react';
import styles from '../styles/AddTodo.module.css';

export const AddTodo: React.FC<{ onAdd: (text: string) => void }> = ({ onAdd }) => {
  const [text, setText] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!text.trim()) {
      setError('Todo text cannot be empty');
      return;
    }
    onAdd(text.trim());
    setText('');
    setError('');
  };

  return (
    <form onSubmit={handleSubmit} className={styles.form}>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder='Add a new todo'
      />
      {error && <div className={styles.error}>{error}</div>}
      <button type='submit'>Add Todo</button>
    </form>
  );
};
```
""" ;
  rdfs:comment "File content used by executor for plan item 4 (AddTodo form & validation)." .

# Step 5 resource
:Resource_Step5_File rdf:type beam:Instance ;
  rdfs:label "step-5: Filters and sorting" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-5.txt" ;
  <http://purl.org/dc/terms/description> """
```tsx
// src/components/TodoFilters.tsx
import React from 'react';

type FilterType = 'all' | 'active' | 'completed';

export const TodoFilters: React.FC<{
  currentFilter: FilterType;
  onFilterChange: (filter: FilterType) => void;
  onSortChange: (ascending: boolean) => void;
}> = ({ currentFilter, onFilterChange, onSortChange }) => (
  <div>
    <select value={currentFilter} onChange={(e) => onFilterChange(e.target.value as FilterType)}>
      <option value='all'>All</option>
      <option value='active'>Active</option>
      <option value='completed'>Completed</option>
    </select>
    <button onClick={() => onSortChange(true)}>Sort A-Z</button>
    <button onClick={() => onSortChange(false)}>Sort Z-A</button>
  </div>
);
```
""" ;
  rdfs:comment "File content used by executor for plan item 5 (filters & sorting)." .

# Step 6 resource
:Resource_Step6_File rdf:type beam:Instance ;
  rdfs:label "step-6: local storage utils" ;
  <http://purl.org/dc/terms/title> "src/agent/open-code/nodes/plan-code/step-6.txt" ;
  <http://purl.org/dc/terms/description> """
```tsx
// src/utils/storage.ts
const STORAGE_KEY = 'todos';

export const saveTodos = (todos: Todo[]) => {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(todos));
};

export const loadTodos = (): Todo[] => {
  const stored = localStorage.getItem(STORAGE_KEY);
  return stored ? JSON.parse(stored) : [];
};
```
""" ;
  rdfs:comment "File content used by executor for plan item 6 (local storage persistence utilities)." .

#################################################################
# Artifacts produced by planner/executor and message contents
#################################################################

:PlanArtifact rdf:type beam:Instance ;
  rdfs:label "Plan artifact (structured plan tool_call args snapshot)" ;
  <http://purl.org/dc/terms/description> """
A JSON snapshot representing the tool_call args returned by the planner:
{
  "executedPlans": [...],
  "rejectedPlans": [...],
  "remainingPlans": [...]
}
This artifact is updated each planner run; initial remainingPlans is the canonical PLAN stored in PlanPrompt.promptInputData.
""" .

:Resource_PlanInput rdf:type beam:Instance ;
  rdfs:label "Plan input resource" ;
  <http://purl.org/dc/terms/description> "Represents inputs consumed by the planner (previous tool_call responses, user approvals). Structured content is stored in PlanPrompt.promptInputData as JSON." .

#################################################################
# Relations describing human involvement and tool responses
#################################################################

# The human participates in approving plan messages and proposed changes
:Human_User :humanParticipatedIn :Task_Planner , :Task_Executor .

# The tools read/write resources (resourceUsage)
:Tool_UpdateFile :resourceUsage :Resource_Step1_File , :Resource_Step2_File , :Resource_Step3_File , :Resource_Step4_File , :Resource_Step5_File , :Resource_Step6_File .

#################################################################
# Additional descriptive individuals and mapping to preserve message content
#################################################################

# Success message emitted by executor when all steps done
:SuccessMessage rdf:type :Prompt ;
  rdfs:label "Executor success message" ;
  :promptOutputIndicator "AI message content emitted when no remaining plan items exist." ;
  :promptInstruction "Successfully completed all the steps in the plan. Please let me know if you need anything else!" .

# The simulated tool response representing user approval (used by planner)
:ToolMessage_UserApproved rdf:type beam:Instance ;
  rdfs:label "Simulated ToolMessage: User Approved Plan" ;
  <http://purl.org/dc/terms/description> "The planner constructs a ToolMessage whose content is 'User has approved the plan.' to represent that the user accepted the plan and the workflow may proceed." .

#################################################################
# Link agent to workflow and goals
#################################################################
:OpenCodeAgent :hasWorkflowPattern :OpenCodeGraphPattern ;
  :hasGoal :Goal_BuildTodoApp .

#################################################################
# Provenance and relationships summary (for reconstruction)
#################################################################
# For an LLM to reconstruct the solution:
# - The planner task (Task_Planner) provides a 'plan' tool_call containing executedPlans, rejectedPlans, remainingPlans. The canonical PLAN is given in PlanPrompt.promptInputData.
# - The executor task (Task_Executor) consumes the plan tool_call and maps the nextPlanItem (remainingPlans[0]) to one of the step file resources (Resource_Step1_File ... Resource_Step6_File) based on numSeenPlans (executed + rejected); it issues an 'update_file' tool_call whose args are captured in UpdateFilePrompt.promptInputData and pushes a UI payload described in UpdateFilePrompt.
# - Human_User participates by approving or rejecting the proposed change; rejections are detected by the planner by searching for the substring "rejected" in the tool response content (see Config_UpdateFileToolConfig).
# - The agent config key permissions.full_write_access controls whether the executor loops back to the planner (full automation) or the workflow ends after success.
# End of individuals.