# Execution time: 104.99 seconds
# Model used: gpt-5-mini

# Issues / Assumptions:
# - The ontology lacks explicit concepts for "thread" (conversation thread ID) and "streaming behavior" (textStream, maskStreamTags, ora spinner). These are represented as literals in prompts/configs instead of structured entities.
# - There is no property to directly link a KnowledgeBase to a storage resource; :agentResourceUsage (domain :LLMAgent) and :hasConfig (range :Config) are used to represent the storage and its configuration. A direct property like "storageFor" would be useful.
# - The ontology does not provide a dedicated property/class for "StorageBackend" or "Database" (only beam:Resource / beam:Instance exist). A beam:Instance is used to model the LibSQL store and file path.
# - There is no explicit property to capture code/SDK-level details (e.g., use of @mastra/core, maskStreamTags, ora spinner, Readline). These implementation specifics are represented as descriptive literals where relevant.
# - The dynamic system message timestamp (`new Date().toISOString()`) and runtime constructs (user selection UI and random UUID generation) cannot be modeled as executable behavior. They are recorded as templates or literal descriptions.
# - The "memory" object and the act of attaching it to an agent via SDK is modeled semantically as a KnowledgeBase (Memory) linked via :hasKnowledge. The ontology does not capture the "injection" mechanism; this is an assumption.
# - No new classes or properties have been added; all modeling uses the existing ontology constructs.

@prefix : <http://www.w3id.org/agentic-ai/onto#> .
@prefix pp: <http://purl.org/net/p-plan#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix beam: <http://w3id.org/beam/core#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@base <http://www.w3id.org/agentic-ai/onto#> .

################################################################################
# Individuals: Agents, Models, Memory, Configs, Prompts, Resources, Workflow
################################################################################

### Agent: Personal Assistant (LLMAgent)
:personalAssistant rdf:type :LLMAgent ;
    dcterms:title "Personal Assistant" ;
    :agentID "personal-assistant" ;
    :agentRole "Personal Assistant" ;
    rdfs:comment "An LLM-based personal assistant configured with persistent per-resource working memory and conversational instructions." ;
    :useLanguageModel :gpt4oMini ;
    :hasKnowledge :memoryDemo ;
    :agentPrompt :assistantInstructionsPrompt ;
    :hasAgentCapability :cap_conversational, :cap_memory_update, :cap_greet_returning_user ;
    :agentResourceUsage :libsqlMemoryDB ;
    :hasAgentConfig :agentConfig_instructions ;
    .

### Language Model used by the agent
:gpt4oMini rdf:type :LanguageModel ;
    dcterms:title "gpt-4o-mini" ;
    dcterms:description "OpenAI model referenced in source code via openai('gpt-4o-mini'). Used as the primary language model for the agent." ;
    .

### Memory (KnowledgeBase) - Per-Resource Working Memory
:memoryDemo rdf:type :Memory ;
    dcterms:title "Per-Resource Working Memory" ;
    rdfs:comment """Working memory instance that persists across conversation threads for the same resource (user). Mirrors the Memory instance configured in the source code and contains configuration keys that define behavior.""";
    :hasConfig :memcfg_lastMessages, :memcfg_workingMemory_enabled, :memcfg_workingMemory_scope, :memcfg_workingMemory_template, :memcfg_storageReference ;
    .

# Memory configuration key/value pairs (each is a Config individual)
:memcfg_lastMessages rdf:type :Config ;
    :configKey "lastMessages" ;
    :configValue "5" ;
    rdfs:comment "Number of recent messages to keep in fast-access context." ;
    .

:memcfg_workingMemory_enabled rdf:type :Config ;
    :configKey "workingMemory.enabled" ;
    :configValue "true" ;
    rdfs:comment "Enables working memory persistence behavior (boolean true/false)." ;
    .

:memcfg_workingMemory_scope rdf:type :Config ;
    :configKey "workingMemory.scope" ;
    :configValue "resource" ;
    rdfs:comment "Scope of working memory persistence. 'resource' indicates per-resource working memory shared across threads for the same resourceId." ;
    .

:memcfg_workingMemory_template rdf:type :Config ;
    :configKey "workingMemory.template" ;
    :configValue """# User Profile
- **Name**: 
- **Location**: 
- **Interests**: 
- **Preferences**: 
- **Goals**: 
- **Important Notes**: 
""" ;
    rdfs:comment "Template text used by the agent to structure working memory updates. Agent is instructed to update this structure using <working_memory> tags." ;
    .

# Link to storage resource (LibSQL store). There is no dedicated Storage class; use beam:Instance as resource representation.
:libsqlMemoryDB rdf:type beam:Instance ;
    dcterms:title "memory-demo-storage" ;
    dcterms:description "LibSQLStore persistent storage used for Memory. Source code: new LibSQLStore({ id: 'memory-demo-storage', url: 'file:./memory-demo.db' }). File path: file:./memory-demo.db" ;
    .

# A Config referencing storage (string value holds connection/url). This is attached to memory via :hasConfig (above).
:memcfg_storageReference rdf:type :Config ;
    :configKey "storage.url" ;
    :configValue "file:./memory-demo.db" ;
    rdfs:comment "Storage backend connection URL for the LibSQL store. Implementation detail: LibSQLStore id 'memory-demo-storage'." ;
    .

### Agent-level config storing long instruction string (also represented as a Prompt for the agent)
:agentConfig_instructions rdf:type :Config ;
    :configKey "instructions" ;
    :configValue """You are a helpful personal assistant with persistent memory across ALL conversations.

ðŸ†• IMPORTANT: You have resource-scoped working memory! This means:
- Everything you learn about this user persists across ALL conversation threads
- Even if they start a completely new conversation, you'll remember them
- You should build up a comprehensive profile of the user over time

Always use <working_memory> tags to update what you know about the user:
- Their name and personal details
- Their interests and preferences  
- Their goals and what they're working on
- Any important context from previous conversations

When you first meet someone, ask for their name and learn about them. In subsequent conversations (even new threads), greet them by name and reference what you remember!""" ;
    .

# The agent prompt as a Prompt individual (linked via :agentPrompt)
:assistantInstructionsPrompt rdf:type :Prompt ;
    :promptInstruction """You are a helpful personal assistant with persistent memory across ALL conversations.

ðŸ†• IMPORTANT: You have resource-scoped working memory! This means:
- Everything you learn about this user persists across ALL conversation threads
- Even if they start a completely new conversation, you'll remember them
- You should build up a comprehensive profile of the user over time

Always use <working_memory> tags to update what you know about the user:
- Their name and personal details
- Their interests and preferences  
- Their goals and what they're working on
- Any important context from previous conversations

When you first meet someone, ask for their name and learn about them. In subsequent conversations (even new threads), greet them by name and reference what you remember!""" ;
    :promptContext "Agent instructions configured at creation time (Agent.instructions in source code)." ;
    .

### Capabilities (linked to the agent)
:cap_conversational rdf:type :Capability ;
    rdfs:label "conversational" ;
    rdfs:comment "Capability to hold a multi-turn conversation and respond to user inputs." ;
    .
:cap_memory_update rdf:type :Capability ;
    rdfs:label "memory_update" ;
    rdfs:comment "Capability to update and persist working memory based on conversation content; expects <working_memory> tags to be used in outputs." ;
    .
:cap_greet_returning_user rdf:type :Capability ;
    rdfs:label "greet_returning_user" ;
    rdfs:comment "Capability to detect returning users and greet them referencing remembered information." ;
    .

### Team / System representing the deployed assistant and its workflow
:personalAssistantSystem rdf:type :Team ;
    dcterms:title "Personal Assistant System" ;
    rdfs:comment "System grouping for the Personal Assistant; associates agent, system config, and workflow pattern." ;
    :hasAgentMember :personalAssistant ;
    :hasWorkflowPattern :PerResourceWorkingMemoryPattern ;
    :hasSystemConfig :systemConfig_default ;
    .

:systemConfig_default rdf:type :Config ;
    :configKey "system.mode" ;
    :configValue "demo" ;
    rdfs:comment "High-level system config for demonstration deployment (non-production example)." ;
    .

################################################################################
# Workflow Pattern: Per-Resource Working Memory Example
################################################################################

:PerResourceWorkingMemoryPattern rdf:type :WorkflowPattern ;
    rdfs:label "Per-Resource Working Memory Pattern" ;
    rdfs:comment "Workflow demonstrating per-resource working memory: start conversation, update memory, interactive chat loop." ;
    :hasWorkflowStep :prwm_startStep, :prwm_updateMemoryStep, :prwm_interactiveChatStep, :prwm_endStep ;
    .

### Workflow steps (ordered)
:prwm_startStep rdf:type :StartStep ;
    :stepOrder 1 ;
    rdfs:label "Start Conversation Step" ;
    :hasAssociatedTask :task_startConversation ;
    :nextStep :prwm_updateMemoryStep ;
    .

:prwm_updateMemoryStep rdf:type :WorkflowStep ;
    :stepOrder 2 ;
    rdfs:label "Process Memory Updates Step" ;
    :hasAssociatedTask :task_updateMemory ;
    :nextStep :prwm_interactiveChatStep ;
    .

:prwm_interactiveChatStep rdf:type :WorkflowStep ;
    :stepOrder 3 ;
    rdfs:label "Interactive Chat Loop Step" ;
    :hasAssociatedTask :task_interactiveChat ;
    :nextStep :prwm_endStep ;
    .

:prwm_endStep rdf:type :EndStep ;
    :stepOrder 4 ;
    rdfs:label "End Step" ;
    rdfs:comment "Marks completion of the demonstration workflow." ;
    .

################################################################################
# Tasks: Represent major activities in the example program
################################################################################

# Task: Start conversation (system prompt instructs the agent to check working memory)
:task_startConversation rdf:type :Task ;
    dcterms:title "Start Conversation" ;
    dcterms:description """Start a new conversation thread. System message template (in source):
`New conversation thread started at ${new Date().toISOString()}. 
This may be a returning user - check your working memory to see if you know them already.
If this is a new user, introduce yourself and learn about them.
If this is a returning user, greet them warmly and reference what you remember!` 
This message is generated at runtime with a timestamp; represented here as a template.""" ;
    :taskPrompt :prompt_startSystemMessage ;
    :performedByAgent :personalAssistant ;
    :contributesToObjective :objective_demoMemoryDemo ;
    .

:prompt_startSystemMessage rdf:type :Prompt ;
    :promptInstruction "New conversation thread started at {timestamp}. This may be a returning user - check your working memory to see if you know them already. If this is a new user, introduce yourself and learn about them. If this is a returning user, greet them warmly and reference what you remember!" ;
    :promptContext "System-level message template created at conversation start. {timestamp} is a runtime placeholder." ;
    :promptOutputIndicator "Expect agent to check memory, greet user, and either introduce or reference remembered details." ;
    .

# Task: Update working memory (agent writes <working_memory> tags; spinner indicates persistence)
:task_updateMemory rdf:type :Task ;
    dcterms:title "Update Working Memory" ;
    dcterms:description """Inspect conversation content and persist updates to per-resource working memory. Source code expects the agent to output updates wrapped with <working_memory> tags; updates are masked in the stream and persisted to LibSQL. UI uses a spinner during persistence but streaming semantics are an implementation detail (not modeled).""" ;
    :taskPrompt :prompt_memoryUpdateInstructions ;
    :performedByAgent :personalAssistant ;
    :requiresResource :libsqlMemoryDB ;
    .

:prompt_memoryUpdateInstructions rdf:type :Prompt ;
    :promptInstruction """When you learn new facts about the user, produce updates wrapped in <working_memory> tags following the working memory template:
# User Profile
- **Name**: 
- **Location**: 
- **Interests**: 
- **Preferences**: 
- **Goals**: 
- **Important Notes**: 

Only include the sections you can fill; do not remove unrelated sections. The runtime will persist these updates per resource (resource = user ID).""" ;
    :promptContext "Instructions for producing working memory update tags." ;
    :promptOutputIndicator "Text containing <working_memory>...</working_memory> sections following the template." ;
    .

# Task: Interactive chat loop (respond to user inputs, exit on 'exit'/'quit')
:task_interactiveChat rdf:type :Task ;
    dcterms:title "Interactive Chat Loop" ;
    dcterms:description """Receive user messages, call the agent with memory context (resource + thread), stream responses to the user. The loop terminates when the user types 'exit' or 'quit'. The code obtains user input via Readline; runtime specifics are not modeled. The agent should use stored working memory where relevant.""" ;
    :taskPrompt :prompt_userMessageHandler ;
    :performedByAgent :personalAssistant ;
    :requiresCapability :cap_conversational ;
    .

:prompt_userMessageHandler rdf:type :Prompt ;
    :promptInstruction "User input (pass-through). Behavior: if the input equals 'exit' or 'quit', end the session. Otherwise, send to agent with memory context { resource: <resource-id>, thread: <thread-id> }." ;
    :promptContext "Runtime user input handler guidance (template)." ;
    :promptOutputIndicator "Agent conversational reply or termination acknowledgment." ;
    .

################################################################################
# Objectives / Goals
################################################################################

:objective_demoMemoryDemo rdf:type :Objective ;
    dcterms:title "Demonstrate per-resource working memory" ;
    rdfs:comment "Objective for the demo: show that working memory persists across conversation threads for the same resource/user." ;
    :contributesToGoal :goal_showMemoryPersistence ;
    .

:goal_showMemoryPersistence rdf:type :Goal ;
    dcterms:title "Show memory persistence across threads" ;
    rdfs:comment "High-level goal: illustrate per-resource memory behavior (persist across threads, separate for different users)." ;
    .

# Link agent and team to goals/objectives
:personalAssistant :hasAgentGoal :goal_showMemoryPersistence .
:personalAssistantSystem :hasObjective :objective_demoMemoryDemo .
:personalAssistantSystem :hasTeamGoal :goal_showMemoryPersistence .

################################################################################
# Resources: Users (simulated resource IDs) and Storage resource already defined
################################################################################

# Simulated users from source code USERS map
:user_alice rdf:type beam:Instance ;
    dcterms:title "user-alice-123" ;
    dcterms:description "Simulated resource ID for Alice (source: USERS.alice = 'user-alice-123')." ;
    .

:user_bob rdf:type beam:Instance ;
    dcterms:title "user-bob-456" ;
    dcterms:description "Simulated resource ID for Bob (source: USERS.bob = 'user-bob-456')." ;
    .

:user_demo rdf:type beam:Instance ;
    dcterms:title "demo-user-789" ;
    dcterms:description "Simulated demo user resource ID (source: USERS.demo = 'demo-user-789')." ;
    .

# Random user generation (runtime) - represented as a template/description
:resource_randomUser rdf:type beam:Instance ;
    dcterms:title "user-{randomUUID}" ;
    dcterms:description "At runtime, a random UUID is used to generate a resource ID (example: user-<uuid>). Represented here as a template; actual UUIDs are generated at runtime." ;
    .

################################################################################
# Tool/Resource usage
################################################################################

# The LibSQL store is used by the agent to persist memory. Agent resource usage links agent to the storage resource.
:personalAssistant :agentResourceUsage :libsqlMemoryDB .

# The Language Model is represented as a resource and is used by the agent (useLanguageModel).
:personalAssistant :useLanguageModel :gpt4oMini .

################################################################################
# Additional descriptive individuals and notes
################################################################################

# A Prompt representing the CLI selection instructions shown to the user in the example (informational; not used at agent runtime)
:prompt_cliUserSelection rdf:type :Prompt ;
    :promptInstruction """Choose a user to simulate:
1. Alice (user-alice-123)
2. Bob (user-bob-456)
3. Demo User (demo-user-789)
4. Or press Enter to use a random user

If a numeric choice is provided the corresponding resource id is used. Otherwise a random resource id (user-<uuid>) is generated. This behavior is part of the demo harness and is represented here as documentation.""" ;
    :promptContext "Demonstration harness: user selection instructions." ;
    .

# Developer note stored as a Prompt-like artifact to preserve spinner/masking behavior description
:prompt_streamingMasking rdf:type :Prompt ;
    :promptInstruction """Runtime behavior: responses are streamed to the client. Working memory updates in the response stream are masked via 'maskStreamTags' for tags named 'working_memory'. A spinner (ora) is shown during persistence; spinner semantics are UI/implementation concerns and are documented here for fidelity, not as executable ontology constructs.""" ;
    :promptContext "Describes streaming masking and spinner UI as used in the example." ;
    .

################################################################################
# End of instance population
################################################################################