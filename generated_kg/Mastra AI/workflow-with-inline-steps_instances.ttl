# Execution time: 59.17 seconds
# Model used: gpt-5-mini

# Issues / Assumptions:
# - The ontology does not include an explicit class/property to represent a "workflow engine" or runtime; I represent the execution engine (Mastra) as an instance of :Tool and the overall deployment as a :Team. No new classes/properties were added.
# - The ontology lacks dedicated properties for schema definitions, input/output variable mappings between steps, and suspend/resume semantics. I model schemas and such metadata as :Config instances (using :configKey / :configValue) and preserve logic in dct:description literals.
# - The ontology has no property to explicitly connect a WorkflowPattern to a Config; I used the existing :hasConfig property (allowed by the ontology) to attach configuration/schema Config individuals to the workflow.
# - Suspend/resume behavior and program control flow (e.g., calls to .suspend(), .commit()) cannot be represented natively; these are captured as textual descriptions on the relevant Task/WorkflowPattern individuals.
# - Mapping of variable names between steps (e.g., stepOne output "doubledValue" -> stepTwo input "valueToIncrement") is represented as explicit descriptions because there is no schema-mapping construct in the ontology.
# - No LLM agents or human agents are present in the source; therefore no :LLMAgent or :HumanAgent individuals are created.

@prefix : <http://www.w3id.org/agentic-ai/onto#> .
@prefix pp: <http://purl.org/net/p-plan#> .
@prefix beam: <http://w3id.org/beam/core#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@base <http://www.w3id.org/agentic-ai/onto#> .

#################################################################
# Instances describing the Mastra workflow solution (my-workflow)
#################################################################

# System / deployment
:mastraSystem a :Team ;
    dct:title "Mastra System" ;
    dct:description "Represents the Mastra deployment that contains the defined workflows." ;
    :hasWorkflowPattern :myWorkflowPattern ;
    :hasSystemConfig :mastraSystemConfig .

:mastraSystemConfig a :Config ;
    :configKey "framework" ;
    :configValue "mastra/core" ;
    dct:description "High-level config indicating the framework used for this workflow deployment." .

# The workflow as a WorkflowPattern
:myWorkflowPattern a :WorkflowPattern ;
    dct:title "my-workflow" ;
    dct:description "Workflow defined in src/mastra/workflows/index.ts with a numeric trigger schema { inputValue: number }. Steps: stepOne -> stepTwo -> stepThree. Committed (myWorkflow.commit())." ;
    :hasConfig :myWorkflowTriggerConfig ;
    :hasWorkflowStep :stepOneStep , :stepTwoStep , :stepThreeStep .

:myWorkflowTriggerConfig a :Config ;
    :configKey "triggerSchema" ;
    :configValue "{\"inputValue\": \"number\"}" ;
    dct:description "Trigger schema for workflow: expects JSON with property inputValue (number). Mirrors: z.object({ inputValue: z.number() })" .

#################################################################
# Workflow Steps and corresponding Tasks (semantic mapping)
#################################################################

# Step 1 / stepOne (StartStep)
:stepOneStep a :StartStep ;
    dct:title "stepOne" ;
    :stepOrder "1"^^xsd:integer ;
    :hasAssociatedTask :taskStepOne ;
    dct:description "Start step that doubles the workflow trigger input." .

:taskStepOne a :Task ;
    dct:title "stepOne Task" ;
    dct:description """
    Execution logic (preserved from source):
    doubledValue = context?.workflow?.state?.triggerData.inputValue * 2

    Notes:
    - The task reads the workflow trigger value at path workflow.state.triggerData.inputValue and outputs doubledValue.
    - Input schema (declared in code): { value: number } (this is the step input schema)
    - Output schema (declared in code): { doubledValue: number }
    """ ;
    :requiresResource :triggerInputResource ;
    :producedResource :stepOneOutputResource ;
    :performedBy :mastraEngineTool ;
    :hasConfig :stepOneInputSchemaConfig , :stepOneOutputSchemaConfig .

:stepOneInputSchemaConfig a :Config ;
    :configKey "inputSchema-stepOne" ;
    :configValue "{\"value\": \"number\"}" ;
    dct:description "stepOne inputSchema as declared in code: z.object({ value: z.number() })" .

:stepOneOutputSchemaConfig a :Config ;
    :configKey "outputSchema-stepOne" ;
    :configValue "{\"doubledValue\": \"number\"}" ;
    dct:description "stepOne outputSchema as declared in code: z.object({ doubledValue: z.number() })" .

:triggerInputResource a beam:Instance ;
    dct:title "triggerData.inputValue" ;
    dct:description "Workflow trigger input resource: inputValue (number) provided when the workflow is triggered." .

:stepOneOutputResource a beam:Instance ;
    dct:title "doubledValue" ;
    dct:description "Numeric output produced by stepOne: doubledValue = trigger.inputValue * 2 (number)." .

# Step 2 / stepTwo
:stepTwoStep a :WorkflowStep ;
    dct:title "stepTwo" ;
    :stepOrder "2"^^xsd:integer ;
    :hasAssociatedTask :taskStepTwo ;
    dct:description "Second step increments a provided numeric value by 1. Expectation: receives a value under input key 'valueToIncrement'." .

:taskStepTwo a :Task ;
    dct:title "stepTwo Task" ;
    dct:description """
    Execution logic (preserved from source):
    incrementedValue = inputData.valueToIncrement + 1

    Notes:
    - stepTwo's declared input schema: { valueToIncrement: number }
    - stepTwo's declared output schema: { incrementedValue: number }
    - Typical dataflow in this workflow: stepOne produces 'doubledValue'. The code's input name is 'valueToIncrement'; implementers should map stepOne.doubledValue -> stepTwo.valueToIncrement at runtime.
    """ ;
    :requiresResource :stepOneOutputResource ;
    :producedResource :stepTwoOutputResource ;
    :performedBy :mastraEngineTool ;
    :hasConfig :stepTwoInputSchemaConfig , :stepTwoOutputSchemaConfig .

:stepTwoInputSchemaConfig a :Config ;
    :configKey "inputSchema-stepTwo" ;
    :configValue "{\"valueToIncrement\": \"number\"}" ;
    dct:description "stepTwo inputSchema as declared in code: z.object({ valueToIncrement: z.number() })" .

:stepTwoOutputSchemaConfig a :Config ;
    :configKey "outputSchema-stepTwo" ;
    :configValue "{\"incrementedValue\": \"number\"}" ;
    dct:description "stepTwo outputSchema as declared in code: z.object({ incrementedValue: z.number() })" .

:stepTwoOutputResource a beam:Instance ;
    dct:title "incrementedValue" ;
    dct:description "Numeric output produced by stepTwo: incrementedValue = inputData.valueToIncrement + 1 (number)." .

# Step 3 / stepThree (EndStep, includes suspend/resume logic)
:stepThreeStep a :EndStep ;
    dct:title "stepThree" ;
    :stepOrder "3"^^xsd:integer ;
    :hasAssociatedTask :taskStepThree ;
    dct:description "Final step: may suspend workflow for confirmation, otherwise returns a thank-you message." .

:taskStepThree a :Task ;
    dct:title "stepThree Task" ;
    dct:description """
    Execution logic (preserved from source):
    if (context?.workflow?.resumeData?.confirm !== 'true') {
      return context?.workflow?.suspend({
        message: 'Do you accept?',
      });
    }

    return {
      message: 'Thank you for accepting',
    };

    Notes:
    - This task implements a suspend/resume pattern: when resumeData.confirm !== 'true', it suspends and requests confirmation with message 'Do you accept?'.
    - On resume with confirm === 'true' the task returns a message 'Thank you for accepting'.
    - The ontology cannot represent runtime suspend/resume mechanics formally; this behavior is captured here as descriptive metadata.
    """ ;
    :producedResource :stepThreeSuspendPromptResource , :stepThreeFinalMessageResource ;
    :performedBy :mastraEngineTool .

:stepThreeSuspendPromptResource a beam:Instance ;
    dct:title "suspendPrompt" ;
    dct:description "Prompt resource produced when stepThree suspends the workflow: message 'Do you accept?'. This is not a Prompt class instance because the code uses a suspend() runtime action; the text is preserved for reconstruction." .

:stepThreeFinalMessageResource a beam:Instance ;
    dct:title "finalMessage" ;
    dct:description "Final message produced if resumeData.confirm === 'true': 'Thank you for accepting'." .

#################################################################
# Tool representing the workflow engine
#################################################################

:mastraEngineTool a :Tool ;
    dct:title "Mastra Engine" ;
    dct:description "Represents the Mastra runtime/engine that executes workflow steps and tasks (mapped to :Tool for lack of a runtime class in ontology)." ;
    :hasToolConfig :mastraEngineConfig .

:mastraEngineConfig a :Config ;
    :configKey "commitCalled" ;
    :configValue "true" ;
    dct:description "Indicates the workflow instance was committed (myWorkflow.commit()). This preserves the developer intent to finalize workflow definition." .

#################################################################
# Misc metadata: mapping notes and variable-level information
#################################################################

:variableMapping-step1_to_step2 a :Config ;
    :configKey "variableMapping" ;
    :configValue "{\"from\": \"stepOne.doubledValue\", \"to\": \"stepTwo.valueToIncrement\"}" ;
    dct:description "Describes the semantic mapping of step outputs to subsequent step inputs (explicit mapping preserved as ontology cannot represent direct variable binding constructs)." .

#################################################################
# Provenance / high-level description
#################################################################

:sourceRepository a :Instance ;
    dct:title "mastra/src/mastra/workflows" ;
    dct:description "Source: src/mastra/workflows/index.ts. Workflow definition and steps preserved as individuals and descriptions in this ontology instance file." .

# End of instance data.